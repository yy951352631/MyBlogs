<!DOCTYPE html>
<html lang="en">
    <!-- title -->




<!-- keywords -->




<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="wtq">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="wtq">
    
    <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    
    <meta name="description" content>
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Redis-高级篇 · 王某人的博客</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href="/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="stylesheet" href="/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href="/assets/favicon.ico">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js" as="script">
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >王某人的个人博客</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">Redis-高级篇</a>
            </div>
    </div>
    
    <a class="home-link" href=/>王某人的个人博客</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            Redis-高级篇
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "Redis">Redis</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">7.7k</span>Reading time: <span class="post-count reading-time">28 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2020/06/24</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h1 id="Redis高级"><a href="#Redis高级" class="headerlink" title="Redis高级"></a>Redis高级</h1><h2 id="Redis在Linux环境下的安装"><a href="#Redis在Linux环境下的安装" class="headerlink" title="Redis在Linux环境下的安装"></a>Redis在Linux环境下的安装</h2><p>下载地址（centos 7.x）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果未安装wget  可使用yum -y install wget 命令对wget进行安装</span></span><br><span class="line">wget http://download.redis.io/releases/redis-4.0.0.tar.gz</span><br><span class="line"><span class="comment">#下载完后解压</span></span><br><span class="line">tar -xvf redis-4.0.0.tar.gz </span><br><span class="line"><span class="comment">#编译安装</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>make install报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis make install出错：</span><br><span class="line">[root@host01 src]<span class="comment"># make install PREFIX=/opt/bosssoft/redis-3.2.9</span></span><br><span class="line">    CC adlist.o</span><br><span class="line">/bin/sh: cc: 未找到命令</span><br><span class="line">make: *** [adlist.o] 错误 127</span><br></pre></td></tr></table></figure>

<p>原因是因为未安装gcc，解决方法：</p>
<blockquote>
<p>yum install gcc-c++ -y</p>
</blockquote>
<p>make install执行成功后安装完成,进入安装目录下的src目录下可以执行redis指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动redis服务器</span></span><br><span class="line">redis-server</span><br><span class="line"><span class="comment">#复制一个SSH渠道，启动客户端</span></span><br><span class="line">redis-cli</span><br></pre></td></tr></table></figure>

<h3 id="切换redis的端口指令"><a href="#切换redis的端口指令" class="headerlink" title="切换redis的端口指令"></a>切换redis的端口指令</h3><blockquote>
<p>服务器端：redis-server –port 6388</p>
<p>连接客户端：redis-cli -p 6388</p>
</blockquote>
<h3 id="Redis指定配置文件启动"><a href="#Redis指定配置文件启动" class="headerlink" title="Redis指定配置文件启动"></a>Redis指定配置文件启动</h3><p>redis.conf配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#过滤掉注释和空格，查看配置文件</span></span><br><span class="line">cat redis.conf |grep -v <span class="string">"#"</span> |grep -v <span class="string">"^$"</span></span><br><span class="line"><span class="comment">#将当前配置文件信息复制到redis-6379.conf文件中</span></span><br><span class="line">cat redis.conf |grep -v <span class="string">"#"</span> |grep -v <span class="string">"^$"</span> &gt;redis-6379.conf</span><br></pre></td></tr></table></figure>

<p>删除其他配置信息后的redis-6379.conf文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br><span class="line"><span class="comment">#守护进程的方式启动,使用本启动方式，redis将以服务的形式存在，日志将不再打印到命令窗口中</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="comment">#日志文件名</span></span><br><span class="line">logfile <span class="string">"6379.log"</span></span><br><span class="line"><span class="comment">#日志文件位置（自己创建一个目录data）</span></span><br><span class="line">dir /home/wtq/redis-4.0.0/data</span><br></pre></td></tr></table></figure>

<p>使用redis-6379.conf作为配置文件启动redis</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-6379.conf</span><br><span class="line"><span class="comment">#查看redis进程（检测是否启动成功）</span></span><br><span class="line">ps -ef | grep redis-</span><br><span class="line"><span class="comment">#结束redis进程</span></span><br><span class="line"><span class="built_in">kill</span> -s 9 11240</span><br></pre></td></tr></table></figure>

<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><blockquote>
<p>利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制成为持久化</p>
</blockquote>
<p>为什么要进行持久化？</p>
<blockquote>
<p>防止数据的意外丢失，确保数据安全性</p>
</blockquote>
<p>持久化过程中保存什么？</p>
<blockquote>
<p>二进制数据（快照）</p>
<p>1.将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据</p>
<p>2.记录操作过程（日志），存储格式复杂，关注点在数据的操作过程。</p>
</blockquote>
<blockquote>
<p>redis中用到的是那种存储方法呢？</p>
<p>答：redis两种存储方式都有用到</p>
</blockquote>
<img src="/2020/06/24/Redis高级/1.png">

<h2 id="RDB的数据备份方式"><a href="#RDB的数据备份方式" class="headerlink" title="RDB的数据备份方式"></a>RDB的数据备份方式</h2><p>RDB启动方法</p>
<blockquote>
<p>谁，什么时间，干什么事</p>
<p>1.谁：redis操作者（用户）</p>
<p>2.什么时间：即时（随时进行）</p>
<p>3.干什么：保存数据</p>
</blockquote>
<p>RDB-持久化命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#每执行一次就会将数据（快照的形式）保存一次</span></span><br><span class="line">save</span><br><span class="line"><span class="comment">#执行后会将当前的数据状态存储到data目录下的dump.rdb文件中</span></span><br></pre></td></tr></table></figure>

<h3 id="RDB相关配置"><a href="#RDB相关配置" class="headerlink" title="RDB相关配置"></a>RDB相关配置</h3><p>1.设置本地数据库的名称</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="comment">#默认为dump.rdb，通常设置为：dump-端口号.rdb</span></span><br></pre></td></tr></table></figure>

<p>2.设置存储.rdb文件的路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br><span class="line"><span class="comment">#通常设置成存储空间较大的目录中，目录名称为data</span></span><br></pre></td></tr></table></figure>

<p>3.设置存储至本数据库时是否压缩数据，默认为yes，蚕蛹LAF压缩</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rdbcompression yes</span><br><span class="line"><span class="comment">#通常默认为开启状态，如果设置为no，可以节省CPU运行时间，但会使储存文件变大（巨大）</span></span><br></pre></td></tr></table></figure>

<p>4.设置是否进行RDB文件格式校验，该校验过程可在写文件和读文件过程中均进行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rdbchecksum yes</span><br><span class="line"><span class="comment">#通常默认为开启状态，如果设置为no，可以节约读写性能约10%时间消耗，但是存储有一定的数据损坏风险。</span></span><br></pre></td></tr></table></figure>

<p>修改配置文件redis-6380.properties</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">port 6380</span><br><span class="line">daemonize yes</span><br><span class="line">logfile &quot;6390.log&quot;</span><br><span class="line">dir /home/wtq/redis-4.0.0/data</span><br><span class="line">dbfilename dump-6380.rdb</span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure>

<p>tips</p>
<blockquote>
<p>当redis服务器启动时，会将save到磁盘的数据加载进内存</p>
</blockquote>
<blockquote>
<p>由于redis单线程的机制，save指令执行时间过长会造成阻塞，因而线上环境中不建议使用save的方式备份</p>
</blockquote>
<img src="/2020/06/24/Redis高级/2.png">

<p>当数据量过大，单线程执行的方式造成效率过低该如何处理？</p>
<blockquote>
<p>处理方案:后台执行</p>
<p>1.谁：redis操作者（用户）发起指令，redis服务器控制指令执行</p>
<p>2.什么时间：即时（发起）；合理时间（执行）</p>
<p>3.做什么：保存数据</p>
</blockquote>
<p>指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#手动启动后台保存操作，但不是立即执行</span></span><br><span class="line">bgsave</span><br></pre></td></tr></table></figure>

<p>执行原理</p>
<blockquote>
<p>1.当输入bgsave指令后，bash将指令发送给redis，redis返回一个“Background saving started”消息，但是并不执行save操作，而是调用fork函数去生成一个子进程，最终创建rdb文件的任务由这个子进程去完成，完成后在日志中返回一个成功消息。示意图如下</p>
</blockquote>
<img src="/2020/06/24/Redis高级/3.png">

<blockquote>
<p>bgsave命令是针对save阻塞问题做的优化，Redis内部所有涉及到PDB操作都应采用bgsave的方式，save命令可以放弃使用。</p>
</blockquote>
<p>涉及到bgsave的配置信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop-write-on-bgsave-error yes</span><br><span class="line"><span class="comment">#后台存储过程中如果出现错误现象，是否停止保存操作，通常设置为开启状态</span></span><br></pre></td></tr></table></figure>

<p>bgsave的问题</p>
<blockquote>
<p>反复执行保存指令，忘记了怎么办？不知道数据产生了多少变化，是否有变化，何时保存？</p>
</blockquote>
<p>解决方案：</p>
<blockquote>
<p>自动执行</p>
<p>谁：redis服务器发起指令（基于条件）</p>
<p>什么时间：满足条件时</p>
<p>干什么事情：保存数据</p>
</blockquote>
<p>配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">save second changes</span><br><span class="line"><span class="comment">#作用：满足限定时间范围内key的变化数量达到指定数量即进行持久化</span></span><br><span class="line"><span class="comment">#参数：1.second：监控时间范围 2.changes:监控key的变化量</span></span><br><span class="line"><span class="comment">#位置：在conf文件中进行配置</span></span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1  <span class="comment">#15分钟内，有一个key变化即进行保存操作</span></span><br><span class="line">save 300 10  <span class="comment">#五分钟内，变化了5个key才进行存储</span></span><br><span class="line"><span class="comment">#具体要根据业务需要来设置</span></span><br></pre></td></tr></table></figure>

<p>save配置的工作原理</p>
<img src="/2020/06/24/Redis高级/4.png">

<blockquote>
<p>注意</p>
<p>1.save配置要根据实际的业务情况进行配置，频度过高或过低都会出现性能问题，结果可能是灾难性的</p>
<p>2.save配置中对于second与changes设置通常具有互补对应关系，尽量不要设置成包含性关系</p>
<p>3.save配置启动后执行的是bgsave操作</p>
</blockquote>
<h3 id="RDB三种启动方式对比"><a href="#RDB三种启动方式对比" class="headerlink" title="RDB三种启动方式对比"></a>RDB三种启动方式对比</h3><table>
<thead>
<tr>
<th align="center">方式</th>
<th align="center">save指令</th>
<th align="center">bgsave指令</th>
<th align="center">save配置</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读写</td>
<td align="center">同步</td>
<td align="center">异步</td>
<td align="center">异步</td>
</tr>
<tr>
<td align="center">阻塞客户端指令</td>
<td align="center">是</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">额外消耗内存</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">启动新进程</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
</tbody></table>
<h3 id="RDB特殊启动形式"><a href="#RDB特殊启动形式" class="headerlink" title="RDB特殊启动形式"></a>RDB特殊启动形式</h3><p>1.全量复制</p>
<blockquote>
<p>在主从复制中详细讲解</p>
</blockquote>
<p>2.服务器运行过程中重启</p>
<blockquote>
<p>debug reload</p>
</blockquote>
<p>3.关闭服务器时指定保存数据</p>
<blockquote>
<p>shutdown save</p>
</blockquote>
<h3 id="RDB的优点"><a href="#RDB的优点" class="headerlink" title="RDB的优点"></a>RDB的优点</h3><blockquote>
<p>1.RDB是一个紧凑压缩的的二进制文件，存储效率高</p>
<p>2.RDB内部存储的redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景</p>
<p>3.RDB的恢复数据速度要比AOF快很多</p>
<p>4.应用：服务器中每x小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复</p>
</blockquote>
<h3 id="RDB的缺点"><a href="#RDB的缺点" class="headerlink" title="RDB的缺点"></a>RDB的缺点</h3><blockquote>
<p>1.RDB方式无论是执行指令还是利用配置，都无法做到实时持久化，具有较大的可能性丢失数据</p>
<p>2.bgsave指令每次运行都要执行fork操作创建子进程，要牺牲掉一些性能</p>
<p>3.Redis的众多版本中，未进行RDB文件格式的版本统一，有可能出现各个版本服务器之间数据格式无法兼容的现象</p>
</blockquote>
<h2 id="AOF的数据备份方式"><a href="#AOF的数据备份方式" class="headerlink" title="AOF的数据备份方式"></a>AOF的数据备份方式</h2><h3 id="RDB存储的弊端"><a href="#RDB存储的弊端" class="headerlink" title="RDB存储的弊端"></a>RDB存储的弊端</h3><blockquote>
<p>1.存储数据量较大，效率较低，基于快照的思想，每次读写都是全部数据，当数据量巨大时，效率非常低</p>
<p>2.大量数据新的IO性能低</p>
<p>3.基于fork创建子进程，内存产生额外消耗</p>
<p>4.宕机带来的数据丢失风险</p>
</blockquote>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><blockquote>
<p>1.不写全数据，进记录部分数据</p>
<p>2.改记录数据为记录操作过程</p>
<p>3.对所有操作均进行记录，排除丢失数据的风险</p>
</blockquote>
<h3 id="AOF概念"><a href="#AOF概念" class="headerlink" title="AOF概念"></a>AOF概念</h3><blockquote>
<p>1.AOF（append only file）持久化：以独立日志的方式记录每次读写命令，重启时再重新执行AOF文件中的命令，达到恢复数据的目的，与RDB相比可以简单描述为：“<strong>改记录数据为记录数据产生的过程</strong>”</p>
<p>2.AOF的主要作用是解决了数据持久化的<strong>实时性</strong>，目前已经是Redis持久化的主流方式</p>
</blockquote>
<h3 id="AOF写数据过程"><a href="#AOF写数据过程" class="headerlink" title="AOF写数据过程"></a>AOF写数据过程</h3><img src="/2020/06/24/Redis高级/5.png">

<p>AOF写数据的三种策略</p>
<p>1.always（每次）</p>
<blockquote>
<p>每次写入操作均同步到AOF文件中，<strong>数据零误差，性能较低</strong></p>
</blockquote>
<p>2.everysec（每秒）</p>
<blockquote>
<p>每秒将缓冲区中的指令同步到AOF文件中，数据<strong>准确性较高，性能较高</strong>，在系统突然宕机的情况下丢失1秒内数据</p>
</blockquote>
<p>3.no（系统控制）</p>
<blockquote>
<p>由于操作系统控制每次同步到AOF文件的周期，整体过程<strong>不可控</strong></p>
</blockquote>
<h3 id="AOF功能开启"><a href="#AOF功能开启" class="headerlink" title="AOF功能开启"></a>AOF功能开启</h3><p>相关配置信息（conf.properties）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#是否开启AOF持久化功能，默认认为不开启状态</span><br><span class="line">appendonly yes|no</span><br><span class="line">#AOF写数据策略</span><br><span class="line">appendfsync always|everysec|no</span><br><span class="line">#AOF持久化文件名，默认文件名为appendonly.aof，建议配置为appendonly-端口号.aof</span><br><span class="line">appendfilename filename</span><br><span class="line">#作用：AOF持久化文件保存路径，与RDB持久化文件保持一致即可</span><br><span class="line">dir</span><br></pre></td></tr></table></figure>

<h3 id="AOF写数据遇到的问题"><a href="#AOF写数据遇到的问题" class="headerlink" title="AOF写数据遇到的问题"></a>AOF写数据遇到的问题</h3><img src="/2020/06/24/Redis高级/6.png">

<p>解决方案：AOF重写</p>
<blockquote>
<p>随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积，AOF文件重写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程，简单来说就是将同一个数据的若干条命令执行结果转化为最终结果数据对指令进行记录。（去掉无效的中间过程）</p>
</blockquote>
<p>AOF重写的作用</p>
<blockquote>
<p>1.降低磁盘占用量，提高磁盘利用率</p>
<p>2.提高持久化效率，降低持久化写时间，提高IO性能</p>
<p>3.降低数据恢复用时，提高数据恢复效率。</p>
</blockquote>
<p>AOF重写规则</p>
<blockquote>
<p>1.进程内已超时的数据不再写入文件</p>
<p>2.忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令，如del key1、hdel key2、srem key3、set key4 111 等。</p>
<p>3.对同一数据的多条写命令合并为一条命令，如lpush list1 a；lpush list1 b可以转化为lpush list1 a b;为防止数据量过大造成客户端缓冲区溢出，对list，set，hash，zset等类型每条指令最多写入64个元素。</p>
</blockquote>
<p>AOF重写方式</p>
<p>1.手动重写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgrewriteaof</span><br></pre></td></tr></table></figure>

<p>bgrewriteaof工作原理</p>
<img src="/2020/06/24/Redis高级/7.png">

<p>2.自动重写</p>
<p>1）自动重写触发条件设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-min-size size</span><br><span class="line">auto-aof-rewrite-percentage percentage</span><br></pre></td></tr></table></figure>

<p>2）自动重写触发比对参数（运行指令info Persistence获取具体信息）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#当前aof文件大小</span><br><span class="line">aof_current_size  </span><br><span class="line">#基础尺寸（可在info信息中查询）</span><br><span class="line">aof_base_size</span><br></pre></td></tr></table></figure>

<p>执行info指令可查看当前redis的相关信息</p>
<img src="/2020/06/24/Redis高级/8.png">

<p>3）自动重写触发条件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）aof_current_size &gt; auto-aof-rewrite-min-size</span><br><span class="line">2）(aof_current_size - aof_base_size)/aof_base_size &gt;= auto-aof-rewrite-percentage</span><br></pre></td></tr></table></figure>

<h3 id="AOF工作流程"><a href="#AOF工作流程" class="headerlink" title="AOF工作流程"></a>AOF工作流程</h3><img src="/2020/06/24/Redis高级/9.png">

<img src="/2020/06/24/Redis高级/10.png">

<h2 id="RDB与AOF的区别及抉择"><a href="#RDB与AOF的区别及抉择" class="headerlink" title="RDB与AOF的区别及抉择"></a>RDB与AOF的区别及抉择</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><table>
<thead>
<tr>
<th>持久化方式</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>占用存储空间</td>
<td>小（数据级：压缩）</td>
<td>大（指令级：重新）</td>
</tr>
<tr>
<td>存储速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>会丢失数据</td>
<td>依据策略决定（相对安全）</td>
</tr>
<tr>
<td>资源消耗</td>
<td>高/重量级</td>
<td>低/轻量级</td>
</tr>
<tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<h3 id="抉择"><a href="#抉择" class="headerlink" title="抉择"></a>抉择</h3><blockquote>
<p>1.对数据非常敏感，建议使用默认的AOF持久化方案</p>
<p>​    1）AOF持久化策略使用everysecond，每秒钟fsync一次，该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据</p>
<p>​    2）注意：由于AOF文件存储体积较大，所以恢复速度较慢</p>
<p>2.数据呈现阶段有效性，建议使用RDB持久化方案</p>
<p>​    1）数据可以良好的做大阶段内无丢失，（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段点数据恢复通常采用PDB方案</p>
<p>​    2）注意：利用RDB实现紧凑的数据持久化会使redis性能大大降低</p>
</blockquote>
<h3 id="综合对比"><a href="#综合对比" class="headerlink" title="综合对比"></a>综合对比</h3><blockquote>
<p>1.RDB与AOF的选择实际上是一种权衡，每种都有利有弊</p>
<p>2.如果不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF</p>
<p>3.如果能够承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB</p>
<p>4.灾难恢复选用RDB</p>
<p>5.双保险策略，同时开启RDB和AOF，重启后Redis优先使用AOF来恢复数据，降低丢失数据的量。</p>
</blockquote>
<h2 id="持久化的应用场景"><a href="#持久化的应用场景" class="headerlink" title="持久化的应用场景"></a>持久化的应用场景</h2><img src="/2020/06/24/Redis高级/11.png">

<h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>什么是事务？</p>
<blockquote>
<p>Redis执行指令过程中，多条连续执行的指令被干扰，打断插队</p>
</blockquote>
<img src="/2020/06/24/Redis高级/12.png">

<blockquote>
<p>答：Redis事务就是一个命令执行的队列，将一系列预定义命令包装成一个整体（一个队列）当执行时，一次性按照添加顺序依次执行，中间不会被打断或者干扰。</p>
<p>关键词：一个队列中，一次性，顺序性，排他性的执行一系列命令。</p>
</blockquote>
<p>事务的边界</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启事务</span></span><br><span class="line">multi</span><br><span class="line"><span class="comment">#multi作用：设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</span></span><br><span class="line"><span class="comment">#执行事务</span></span><br><span class="line"><span class="built_in">exec</span></span><br><span class="line"><span class="comment">#exec作用：设定事务的结束位置，同时执行事务，与multi成对出现，成对使用。</span></span><br></pre></td></tr></table></figure>

<p>事务定义过程中出现了问题，怎么办？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#取消事务</span></span><br><span class="line">discard</span><br><span class="line"><span class="comment">#discard作用：终止当前事务的定义，发生在multi之后，exec之前，执行后相当于把之前的multi连同multi下的操作一同清除掉了</span></span><br></pre></td></tr></table></figure>

<p>事务的工作流程</p>
<img src="/2020/06/24/Redis高级/13.png">

<p>定义事务的过程中，命令格式输入错误怎么办？</p>
<blockquote>
<p>语法错误：指令书写格式错误</p>
<p>处理结果：如果定义的事物中所包含的命令存在语法错误，整体事物中所有命令均不会执行，包括那些语法正确的命令。</p>
</blockquote>
<p>定义事务的过程中，命令执行出现错误怎么办？</p>
<blockquote>
<p>运行错误：指令格式正确，但是无法正确执行，例如对list进行incr操作</p>
<p>处理结果：能够正确运行的命令会执行，运行错误的命令不会被执行。</p>
</blockquote>
<p>注意：</p>
<blockquote>
<p>已经执行完毕的命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚。（尽量避免出现需要回滚的现象）</p>
</blockquote>
<p>手动进行事务回滚（较为鸡肋，不常用）</p>
<blockquote>
<p>记录操作过程中，被影响的数据之前的状态（在程序中记录）</p>
<p>​    单数据：string</p>
<p>​    多数据：hash、list、set、zset</p>
<p>设置指令恢复所有的被修改的项</p>
<p>​    单数据：直接set（注意周边属性，例如时效）</p>
<p>​    多数据：修改对应值或整体克隆赋值</p>
</blockquote>
<h3 id="锁，基于特定条件的事物执行"><a href="#锁，基于特定条件的事物执行" class="headerlink" title="锁，基于特定条件的事物执行"></a>锁，基于特定条件的事物执行</h3><p>业务场景</p>
<blockquote>
<p>天猫双11热卖过程中，对已经售光的货物追加补货，4个业务员都有权限进行补货，补货的操作可能是一系列的操作，牵扯到多个连续的操作，如何保障不会有重复操作?</p>
</blockquote>
<p>业务分析</p>
<blockquote>
<p>多个客户端有可能同时操作同一组数据，并且该数据一旦被操作修改后，将不使用于继续操作。</p>
<p>在操作之前锁定要操作的数据，一旦发生变化，终止当前操作。</p>
</blockquote>
<p>解决方案</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对key添加监视锁，在执行exec前如果key发生了变化，终止事务执行(在开启事务之前使用)</span></span><br><span class="line">watch key1 key2 ....</span><br><span class="line"><span class="comment">#取消对所有key的监视</span></span><br><span class="line">unwatch</span><br></pre></td></tr></table></figure>

<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>业务场景</p>
<blockquote>
<p>天猫双11热卖过程中，对已经售光的货物追加补货，且补货完成，客户购买热情高涨，三秒内将所有物品购买完毕，本次补货已经将库存全部清空，如何避免最后一件商品不被多人同时购买？（超卖问题）</p>
</blockquote>
<p>业务分析</p>
<blockquote>
<p>1.使用watch监控一个key有没有改变已经不能解决问题，此处要监控的是具体的数据</p>
<p>2.虽然redis是单线程的，但是多个客户端对同一数据同时进行操作时，如何避免被同时修改？</p>
</blockquote>
<p>解决方案</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用setnx设置一个公共锁</span></span><br><span class="line">setnx lock-key value</span><br><span class="line"><span class="comment">#实际案例</span></span><br><span class="line"><span class="comment">#1.设置锁</span></span><br><span class="line">setnx lock-num 1</span><br><span class="line"><span class="comment">#2.返回值为1则拿到控制权，进行数据操作</span></span><br><span class="line">incr num -1</span><br><span class="line"><span class="comment">#3.操作完毕，释放锁(释放之前，其他的setnx lock-num 1操作返回值都是0，即失败)</span></span><br><span class="line">del lock-num</span><br></pre></td></tr></table></figure>

<blockquote>
<p>利用setnx命令的返回值特征，有值则返回设置失败，无值则返回设置成功</p>
<p>​    对于返回设置成功的，拥有控制权，进行下一步具体的业务操作，</p>
<p>​    对于返回值失败的，不具有控制权，排队或等待。操作完毕</p>
<p>操作完毕通过del操作释放锁。</p>
</blockquote>
<p>注意</p>
<blockquote>
<p>上述解决方案是一种设计概念，依赖规范保障，具有风险性。（必须保障各个客户端使用的是同一把锁）</p>
</blockquote>
<h3 id="死锁解决方案"><a href="#死锁解决方案" class="headerlink" title="死锁解决方案"></a>死锁解决方案</h3><p>业务场景</p>
<blockquote>
<p>依赖分布式锁的机制，某个用户操作时对应客户宕机，且此时已经获取到锁，如何解决？</p>
</blockquote>
<p>业务分析</p>
<blockquote>
<p>1.由于锁操作由用户控制加锁解锁，必定会存在加锁后未解锁的风险</p>
<p>2.需要解决操作不能仅依赖用户控制，系统级别要给出对应的保底处理方案。</p>
</blockquote>
<p>解决方案</p>
<p>使用expire为锁key添加时间限定，到时不释放，放弃锁</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expire lock-key second</span><br><span class="line">pexpire lock-key millisecond</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于操作通常都是微妙或者毫秒级，因此锁定时间不宜设置过大，具体时间需要业务测试后确认</p>
<p>​    1）例如：持有锁的操作最长执行时间127ms最短执行时间7ms</p>
<p>​    2）测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时</p>
<p>​    3）锁时间设定推荐：最大耗时<em>120%+平均网络延迟</em>110%</p>
<p>​    4）如果业务最大耗时&lt;&lt;网络平均延迟（或相反），通常为两个数量级，取其中单个耗时较长的数据进行计算即可。</p>
</blockquote>
<h2 id="Redis删除策略"><a href="#Redis删除策略" class="headerlink" title="Redis删除策略"></a>Redis删除策略</h2><blockquote>
<p>Redis是一种内存级数据库，所有数据均存放在内存中，，内存中的数据可以通过TTL(Time To Live即生存时间)，指令获取其状态。</p>
<p>（ttl key指令）以下几种情况</p>
<p>​    1）xx：具有时效性的数据</p>
<p>​    2）-1：永久有效的数据</p>
<p>​    3）-2：已经过期的数据，或者被删除的数据，或者从未定义过的数据</p>
</blockquote>
<p>问题：过期的数据真的删除了吗？</p>
<blockquote>
<p>答：不一定，Redis会优先处理set和get操作</p>
</blockquote>
<p>数据删除策略</p>
<blockquote>
<p>1.定时删除</p>
<p>2.惰性删除</p>
<p>3.定期删除</p>
</blockquote>
<p>时效性数据的存储结构</p>
<img src="/2020/06/24/Redis高级/14.png">

<p>数据删除策略的目标</p>
<blockquote>
<p>在<strong>内存占用</strong>与<strong>CPU占用</strong>之间寻找一种平衡，顾此失彼都会造成整体Redis性能的下降，甚至引发服务器宕机或内存泄露</p>
</blockquote>
<h3 id="具体的删除策略"><a href="#具体的删除策略" class="headerlink" title="具体的删除策略"></a>具体的删除策略</h3><p>1）定时删除</p>
<blockquote>
<p>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作。</p>
</blockquote>
<p>优缺点</p>
<blockquote>
<p>优点：节约内存，到时就删，快速释放掉不必要的内存占用。</p>
<p>缺点：CPU压力很大，无论CPU此时负载量多高，均会占用CPU，会影响redis服务器响应时间和指令吞吐量。</p>
<p>总结：用处理器的性能换区存储空间。（拿时间换空间）</p>
</blockquote>
<p>2）惰性删除</p>
<blockquote>
<p>数据达到过期时间，不做处理，等下次访问该数据时才进行删除。</p>
<p>在执行get xxx指令前，redis内部会先执行一个函数（expireIfNeeded（））</p>
<p>​    如果数据未过期，则返回数据</p>
<p>​    如果发现数据已经过期，删除，返回不存在</p>
</blockquote>
<p>优缺点</p>
<blockquote>
<p>优点：节约CPU性能，发现必须删除的时候才删除</p>
<p>缺点：内存压力很大，出现长期占用内存的数据</p>
<p>总结：用存储空间换取处理器性能（拿空间换时间）</p>
</blockquote>
<p>3）定期删除</p>
<blockquote>
<p>1.Redis启动服务器初始化时，读取配置server.hz的值，默认为10（可通过info server查看hz值）</p>
<p>2.每秒钟执行server.hz次serverCron()–&gt;databaseCron();对每个数据库中的expire[i]进行轮询，</p>
<p>3.databaseCron();又会调用activeExpireCycle();对每个expires[*]进行逐一检测，每次执行250ms/server.hz</p>
<p>4.对某个expires[*]检测时，随机挑选W个key进行检查</p>
<p>​    ①如果key超时，删除key</p>
<p>​    ②如果一轮中删除的key数量&gt;W*25%，则循环该过程。</p>
<p>​    ③如果一轮中删除的key数量&lt;=W*25%，则检查下一个expires[]，0-15循环</p>
<p>​    ④W取值=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP属性值（在配置文件中配置）</p>
<p>​    ⑤参数current_db用于记录activeExpireCycle()进入哪个expires[*]执行</p>
</blockquote>
<img src="/2020/06/24/Redis高级/15.png">

<blockquote>
<p>总结：简单来说，就是每秒执行执行server.hz次serverCron()操作，serverCron()调用databaseCron()对数据库进行遍历，在每个数据库中调用activeExpireCycle()函数，随机挑选W个key进行检测，检测发现过期则进行删除，如果删除量&gt;挑选总量（W）*25%，则对当前库进行重新遍历挑选删除，如果（&lt;），则由外层循环databaseCron()访问下一个数据库。</p>
</blockquote>
<p>定期删除的特点</p>
<blockquote>
<p>1.周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度。</p>
<p>2.CPU性能占用设置有峰值，检测频度可自定义设置</p>
<p>3.内存压力不是很大，长期占用内存的冷数据会被持续清理</p>
<p>总结：周期性抽查存储空间（随机抽查，重点抽查）。</p>
</blockquote>
<h3 id="删除策略比对"><a href="#删除策略比对" class="headerlink" title="删除策略比对"></a>删除策略比对</h3><table>
<thead>
<tr>
<th>策略</th>
<th>特点1</th>
<th>特点2</th>
<th>总结</th>
</tr>
</thead>
<tbody><tr>
<td>定时删除</td>
<td>节约内存，无占用</td>
<td>不分时段占用CPU资源，频度高</td>
<td>拿时间换空间</td>
</tr>
<tr>
<td>惰性删除</td>
<td>内存占用严重</td>
<td>延时执行，CPU利用率高</td>
<td>拿空间换时间</td>
</tr>
<tr>
<td>定期删除</td>
<td>内存定期随机清理.</td>
<td>每秒花费固定的CPU资源维护内存</td>
<td>随机抽查，重点抽查</td>
</tr>
</tbody></table>
<h2 id="逐出算法"><a href="#逐出算法" class="headerlink" title="逐出算法"></a>逐出算法</h2><p>当新数据进入redis时，如果内存不足怎么办？</p>
<blockquote>
<p>Redis使用内存存储数据，在执行每一个命令前都会调用freeMemoryIfNeeded()检测内存是否充足，如果内存不满足新加入数据的最低要求，redis要临时删除一些数据为当前指令清理存储空间，清理数据的策略成为逐出算法。（淘汰策略）</p>
<p>注意：逐出数据的过程不是100%能够清理出足够的可使用内存空间，如果不成功则反复执行，当对所有数据尝试完毕后，如果仍旧不能达到内存清理的要求，将出现错误信息（报错）。</p>
</blockquote>
<h3 id="影响数据逐出的相关配置"><a href="#影响数据逐出的相关配置" class="headerlink" title="影响数据逐出的相关配置"></a>影响数据逐出的相关配置</h3><p>1）最大可使用内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#占用物理内存的比例，默认0表示不限制，生产环境中根据需求设定，通常在50%以上。</span><br><span class="line">maxmemory</span><br></pre></td></tr></table></figure>

<p>2）每次选取待删除数据的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#选取数据时并不会全库扫描，导致严重的性能消耗，因此采用随机获取的方式作为待检测删除数据</span><br><span class="line">maxmemory-samples</span><br></pre></td></tr></table></figure>

<p>3）删除策略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#达到最大内存后的，被挑选出来的数据进行删除的策略</span><br><span class="line">maxmemory-policy</span><br></pre></td></tr></table></figure>

<p>检测易失数据（可能会过期的数据集server.db[i].expires）</p>
<blockquote>
<p>1.volatile-lru:挑选最近最少使用的数据淘汰（Least Recently Used）（建议使用策略）</p>
<p>2.volatile-lfu:挑选最近使用次数最少的数据淘汰(Least Frequently Used)</p>
<p>3.volatile-ttl:挑选将要过期的数据淘汰</p>
<p>4.volatile-random:任意选择淘汰数据</p>
</blockquote>
<p>检测全库数据（所有数据集server.db[i].dict）</p>
<blockquote>
<p>5.allkeys-lru:挑选最近最少使用的数据淘汰</p>
<p>6.allkeys-lfu:挑选最近使用次数最少的数据淘汰</p>
<p>7.allkeys-random:任意选择数据淘汰</p>
</blockquote>
<p>放弃数据驱逐</p>
<blockquote>
<p>8.no-enviction(驱逐)：禁止驱逐数据，（redis4.0中默认策略），会引发OOM（Out Of Memory）</p>
</blockquote>
<p>配置方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure>

<p>可以使用INFO命令输出监控信息，查询缓存hit和miss（命中和丢失）的次数，根据业务需求调优Redis配置。</p>
<img src="/2020/06/24/Redis高级/16.png">

<p>总结</p>
<blockquote>
<p>无论使用何种策略，都会损耗掉一定的CPU性能或是内存，因而针对不同的场景，要权衡好两者的取舍，达到一个相对平衡的状态。</p>
</blockquote>
<h2 id="Redis核心配置redis-conf"><a href="#Redis核心配置redis-conf" class="headerlink" title="Redis核心配置redis.conf"></a>Redis核心配置redis.conf</h2><p>服务器基础配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#1.设置服务器以守护进程的方式运行</span><br><span class="line">daemonize yes|no</span><br><span class="line">#2.绑定主机地址,绑定后只能通过这个ip访问</span><br><span class="line">bind 127.0.0.1</span><br><span class="line">#3.设置服务器的端口号</span><br><span class="line">port 6379</span><br><span class="line">#4.设置数据库的数量</span><br><span class="line">databases 16</span><br></pre></td></tr></table></figure>

<p>日志配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#1.设置服务器以指定日志记录级别</span><br><span class="line">loglevel debbug|verbose|notice|watning</span><br><span class="line">#2.日志记录文件名</span><br><span class="line">logfile 端口号.log</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：日志级别开发期设置为verbose（默认），生产环境配置为notice，简化日志输出量，降低写日志IO的频度。</p>
</blockquote>
<p>客户端配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#1.设置同一时间最大客户端连接数，默认0表示无限制，当客户端连接达到上限，redis会关闭新的连接</span><br><span class="line">maxclients 0</span><br><span class="line">#2.客户端闲置等待的最大时长，达到最大值后关闭连接，如需关闭该功能，设置为0</span><br><span class="line">timeout 300 </span><br><span class="line">#300秒不用即断开连接</span><br></pre></td></tr></table></figure>

<p>多服务器快捷配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#1.导入并加载指定配置文件信息，用于快速创建redis公共配置较多的redis实例配置文件，便于维护</span><br><span class="line">include /path/server-端口号.conf</span><br></pre></td></tr></table></figure>

<h2 id="Redis的高级数据类型"><a href="#Redis的高级数据类型" class="headerlink" title="Redis的高级数据类型"></a>Redis的高级数据类型</h2><blockquote>
<p>这种类型往往是为了解决一类业务而诞生的</p>
</blockquote>
<h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><blockquote>
<p>可以理解为：spring中二进制位操作的一个接口，直接对bit位进行操作（针对状态类的数据），是最为节省空间的存储方式（但是存入或取出会相对麻烦一些，可以理解为用时间换空间）</p>
</blockquote>
<img src="/2020/06/24/Redis高级/17.png">

<p>Bitmaps类型的基本操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.获取指定key对应偏移量上的bit值</span></span><br><span class="line">getbit key offset</span><br><span class="line"><span class="comment">#2.设置指定key对应偏移量上的bit值，value只能是1或0</span></span><br><span class="line">setbit key offset value</span><br></pre></td></tr></table></figure>

<p>tips.</p>
<blockquote>
<p>如果编号的偏移量较大且编号连续，建议先将偏移量统一减去一个值后作为新的编号。</p>
</blockquote>
<p>Bitmaps类型的扩展操作</p>
<p>业务场景</p>
<blockquote>
<p>电影网站</p>
<p>​    1）统计每一天某一部电影是否被点播</p>
<p>​    2）统计每天有多少部电影被点播</p>
<p>​    3）统计每周/月/年有多少电影被点播</p>
<p>​    4）统计年度那部电影没有被点播</p>
</blockquote>
<p>业务分析</p>
<blockquote>
<p>取出电影的id，比如</p>
<p>《复联2》  id：5 ；offset:4 今天被点播  不考虑其他电影，则结果为：</p>
<p>00001000</p>
<p>统计哪部电影没有被点播：可以将每天的结果进行按位或操作，最终是0的即没有被点播过（可以考虑下架该电影）</p>
</blockquote>
<p>具体操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.对指定key按位进行交，并，非，异或操作，并将结果保存到destKey中</span></span><br><span class="line">bitop op destKey key1 key2 ...</span><br><span class="line"><span class="comment"># and : 交</span></span><br><span class="line"><span class="comment"># or  : 并</span></span><br><span class="line"><span class="comment"># not : 非</span></span><br><span class="line"><span class="comment"># xor : 异或</span></span><br><span class="line"><span class="comment">#2.统计指定key中1的数量</span></span><br><span class="line">bitcount key [start end]</span><br></pre></td></tr></table></figure>

<p>测试数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setbit 20880808 0 1</span><br><span class="line">setbit 20880808 4 1</span><br><span class="line">setbit 20880808 6 1</span><br><span class="line">setbit 20880808 8 1</span><br><span class="line">setbit 20880809 0 1</span><br><span class="line">setbit 20880809 5 1</span><br><span class="line">setbit 20880809 8 1</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#操作1.查看日期为20880808当天共有多少个电影被浏览</span></span><br><span class="line">bitcount 20880808</span><br><span class="line"><span class="comment">#2.查看这两天都有哪些电影被观看</span></span><br><span class="line">bitop or 08-09 20880808 20880809</span><br></pre></td></tr></table></figure>

<blockquote>
<p>redis应用于信息状态统计</p>
</blockquote>
<p>HyperLogLog</p>
<p>用于统计不重复数据的个数，如前面提到的独立统计UV</p>
<blockquote>
<p>原始方案：set   </p>
<p>​    存储每个用户的id（字符串）</p>
<p>改进方案：Bitmaps</p>
<p>​    登录即使用id作为编号记录一下（效率有提升，但数据量还是比较庞大）</p>
<p>全新方案：HyperLogLog</p>
<p>​    用来做基数统计</p>
<p>​    基数是数据集去重后元素个数</p>
</blockquote>
<img src="/2020/06/24/Redis高级/18.png">

<p>HyperLogLog类型的基本操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.添加数据</span></span><br><span class="line">pfadd key element1 element2 ..</span><br><span class="line"><span class="comment">#2.统计数据</span></span><br><span class="line">pfcount key1 key2 ...</span><br><span class="line"><span class="comment">#3.合并数据</span></span><br><span class="line">pfmerge destkey sourcekey1 sourcekey1 ..</span><br></pre></td></tr></table></figure>

<p>tips.</p>
<blockquote>
<p>1.redis可应用于独立信息统计</p>
<p>2.HyperLogLog用于进行基数统计，不是集合，不保存数据，只记录数量而不是具体的数据</p>
<p>3.核心是基数估算算法，最终数值存在一定偏差</p>
<p>4.误差范围：基数估计的结果是一个带有0.81%标准错误的近似值</p>
<p>5.占用空间极小，每个hyperloglog key占用了12k的内存用于标记基数</p>
<p>6.pfadd命令不是一次性分配12k内存使用，会随着基数的增加内存逐渐增大。</p>
<p>7.pfmerge命令合并后占用的存储空间为12k，无论合并之前数据量是多少</p>
</blockquote>
<h3 id="GEO数据类型"><a href="#GEO数据类型" class="headerlink" title="GEO数据类型"></a>GEO数据类型</h3><blockquote>
<p>主要应用于点对点的距离信息</p>
</blockquote>
<p>GEO类型的基本操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.添加坐标点(经纬度，地理位置名)</span></span><br><span class="line">geoadd key longitude latitude member [longitude latitude member...]</span><br><span class="line"><span class="comment">#2.获取坐标点</span></span><br><span class="line">geopos key member [member ...]</span><br><span class="line"><span class="comment">#3.计算坐标点距离</span></span><br><span class="line">geodist key member1 member2 [unit]</span><br><span class="line"><span class="comment">#4.根据坐标求范围内的数据</span></span><br><span class="line">georadius key longitude latitude radius m|km|ft|mi [withcoord] [withdist][withhash] [count count] [asc/desc]</span><br><span class="line"><span class="comment">#5.根据点求范围内数据</span></span><br><span class="line">georadiusbymember key member radius m|km|ft|mi [withcoord] [withdist][withhash] [count count]</span><br><span class="line"><span class="comment">#6.获取指定点对应的坐标hash值</span></span><br><span class="line">geohash key member [member ...]</span><br></pre></td></tr></table></figure>

<img src="/2020/06/24/Redis高级/19.png">

<p>测试数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">geoadd geos 1 1 1,1</span><br><span class="line">geoadd geos 1 2 1,2</span><br><span class="line">geoadd geos 1 3 1,3</span><br><span class="line">geoadd geos 2 1 2,1</span><br><span class="line">geoadd geos 2 2 2,2</span><br><span class="line">geoadd geos 2 3 2,3</span><br><span class="line">geoadd geos 3 1 3,1</span><br><span class="line">geoadd geos 3 2 3,2</span><br><span class="line">geoadd geos 3 3 3,3</span><br><span class="line">geoadd geos 5 5 5,5</span><br><span class="line"><span class="comment">#或者一条指令</span></span><br><span class="line">geoadd geos 1 1 1,1 1 2 1,2 1 3 1,3 2 1 2,1 2 2 2,2 2 3 2,3 3 1 3,1 3 2 3,2 3 3 3,3 5 5 5,5</span><br><span class="line"><span class="comment">#1.求距离坐标点2,2 180km范围内的坐标点</span></span><br><span class="line">georadiusbymember geos 2,2 180 km</span><br><span class="line"><span class="comment">#2.用坐标求周围点并附带距离</span></span><br><span class="line">georadius geos 2 2 150 km withdist</span><br></pre></td></tr></table></figure>

<p>tips.</p>
<blockquote>
<p>redis可以用于地理位置的计算，（距离精度较低）</p>
</blockquote>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>Author：<a href="http://none">wtq</a>
            <p>原文链接：<a href="http://none/2020/06/24/Redis高级/">http://none/2020/06/24/Redis高级/</a>
            <p>发表日期：<a href="http://none/2020/06/24/Redis高级/">June 24th 2020, 12:00:00 am</a>
            <p>更新日期：<a href="http://none/2020/06/24/Redis高级/">June 24th 2020, 5:09:30 pm</a>
            <p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2020/06/21/SQL语句练习/" title= "SQL查询练习">
                    <div class="prevTitle">SQL查询练习</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:951352631@qq.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="https://github.com/yy951352631" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis高级"><span class="toc-number">1.</span> <span class="toc-text">Redis高级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis在Linux环境下的安装"><span class="toc-number">1.1.</span> <span class="toc-text">Redis在Linux环境下的安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#切换redis的端口指令"><span class="toc-number">1.1.1.</span> <span class="toc-text">切换redis的端口指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis指定配置文件启动"><span class="toc-number">1.1.2.</span> <span class="toc-text">Redis指定配置文件启动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#持久化"><span class="toc-number">1.2.</span> <span class="toc-text">持久化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RDB的数据备份方式"><span class="toc-number">1.3.</span> <span class="toc-text">RDB的数据备份方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB相关配置"><span class="toc-number">1.3.1.</span> <span class="toc-text">RDB相关配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB三种启动方式对比"><span class="toc-number">1.3.2.</span> <span class="toc-text">RDB三种启动方式对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB特殊启动形式"><span class="toc-number">1.3.3.</span> <span class="toc-text">RDB特殊启动形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB的优点"><span class="toc-number">1.3.4.</span> <span class="toc-text">RDB的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB的缺点"><span class="toc-number">1.3.5.</span> <span class="toc-text">RDB的缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF的数据备份方式"><span class="toc-number">1.4.</span> <span class="toc-text">AOF的数据备份方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB存储的弊端"><span class="toc-number">1.4.1.</span> <span class="toc-text">RDB存储的弊端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决思路"><span class="toc-number">1.4.2.</span> <span class="toc-text">解决思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF概念"><span class="toc-number">1.4.3.</span> <span class="toc-text">AOF概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF写数据过程"><span class="toc-number">1.4.4.</span> <span class="toc-text">AOF写数据过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF功能开启"><span class="toc-number">1.4.5.</span> <span class="toc-text">AOF功能开启</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF写数据遇到的问题"><span class="toc-number">1.4.6.</span> <span class="toc-text">AOF写数据遇到的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF工作流程"><span class="toc-number">1.4.7.</span> <span class="toc-text">AOF工作流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RDB与AOF的区别及抉择"><span class="toc-number">1.5.</span> <span class="toc-text">RDB与AOF的区别及抉择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#区别"><span class="toc-number">1.5.1.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抉择"><span class="toc-number">1.5.2.</span> <span class="toc-text">抉择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#综合对比"><span class="toc-number">1.5.3.</span> <span class="toc-text">综合对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#持久化的应用场景"><span class="toc-number">1.6.</span> <span class="toc-text">持久化的应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis事务"><span class="toc-number">1.7.</span> <span class="toc-text">Redis事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#锁，基于特定条件的事物执行"><span class="toc-number">1.7.1.</span> <span class="toc-text">锁，基于特定条件的事物执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分布式锁"><span class="toc-number">1.7.2.</span> <span class="toc-text">分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁解决方案"><span class="toc-number">1.7.3.</span> <span class="toc-text">死锁解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis删除策略"><span class="toc-number">1.8.</span> <span class="toc-text">Redis删除策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#具体的删除策略"><span class="toc-number">1.8.1.</span> <span class="toc-text">具体的删除策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除策略比对"><span class="toc-number">1.8.2.</span> <span class="toc-text">删除策略比对</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#逐出算法"><span class="toc-number">1.9.</span> <span class="toc-text">逐出算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#影响数据逐出的相关配置"><span class="toc-number">1.9.1.</span> <span class="toc-text">影响数据逐出的相关配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis核心配置redis-conf"><span class="toc-number">1.10.</span> <span class="toc-text">Redis核心配置redis.conf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis的高级数据类型"><span class="toc-number">1.11.</span> <span class="toc-text">Redis的高级数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bitmaps"><span class="toc-number">1.11.1.</span> <span class="toc-text">Bitmaps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GEO数据类型"><span class="toc-number">1.11.2.</span> <span class="toc-text">GEO数据类型</span></a></li></ol></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 31
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/24</span><a class="archive-post-title" href= "/2020/06/24/Redis高级/" >Redis-高级篇</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/21</span><a class="archive-post-title" href= "/2020/06/21/SQL语句练习/" >SQL查询练习</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/18</span><a class="archive-post-title" href= "/2020/06/18/Redis基础/" >Redis-基础篇</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/15</span><a class="archive-post-title" href= "/2019/10/15/ShardingJDBC-01/" >ShardingJdbc-01</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/09</span><a class="archive-post-title" href= "/2019/10/09/Swagger学习/" >Swagger</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/20</span><a class="archive-post-title" href= "/2019/09/20/分布式事务-Seata/" >分布式事务学习-02-seata实操</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/11</span><a class="archive-post-title" href= "/2019/09/11/JPA学习-04/" >JPA学习-04</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span><a class="archive-post-title" href= "/2019/09/10/JPA学习-02/" >JPA学习-02</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span><a class="archive-post-title" href= "/2019/09/10/JPA学习-01/" >JPA学习-01</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span><a class="archive-post-title" href= "/2019/09/10/分布式事务-概念原理/" >分布式事务学习-01-Seata概念原理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span><a class="archive-post-title" href= "/2019/09/10/JPA学习-03/" >JPA学习-03</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/02</span><a class="archive-post-title" href= "/2019/09/02/Quartz/" >Quartz任务调度</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/28</span><a class="archive-post-title" href= "/2019/08/28/Java基础-01/" >Java基础-01-Optional</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/27</span><a class="archive-post-title" href= "/2019/08/27/Java基础-02/" >Java基础-02-Predicate</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/27</span><a class="archive-post-title" href= "/2019/08/27/SpringCloud学习-06/" >SpringCloud-06-Getaway</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/22</span><a class="archive-post-title" href= "/2019/08/22/SpringCloud学习-05/" >SpringCloud-05-Hystrix</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/20</span><a class="archive-post-title" href= "/2019/08/20/Java基础-03/" >Java基础-03-JVM</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/20</span><a class="archive-post-title" href= "/2019/08/20/Java基础-04/" >Java基础-04-Lambda</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/20</span><a class="archive-post-title" href= "/2019/08/20/SpringCloud学习-04/" >SpringCloud-04-Feign</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/20</span><a class="archive-post-title" href= "/2019/08/20/杂货铺/" >杂乱的知识，定期归档到其他文件</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/20</span><a class="archive-post-title" href= "/2019/08/20/分布式事务学习-01/" >分布式事务</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/16</span><a class="archive-post-title" href= "/2019/08/16/SpringCloud学习-03/" >SpringCloud-03-Ribbon</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/14</span><a class="archive-post-title" href= "/2019/08/14/SpringCloud学习-02/" >SpringCloud-02-Eureka</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/13</span><a class="archive-post-title" href= "/2019/08/13/Maven/" >Maven-01</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/13</span><a class="archive-post-title" href= "/2019/08/13/SpringCloud学习-01/" >SpringCloud-01-配置中心</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/12</span><a class="archive-post-title" href= "/2019/08/12/SpringBoot学习-04/" >SpringBoot-04-JDBC</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/10</span><a class="archive-post-title" href= "/2019/08/10/SpringBoot学习-03/" >SpringBoot-03-servlet容器</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/09</span><a class="archive-post-title" href= "/2019/08/09/SpringBoot学习-02/" >SpringBoot-02-Web工程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/08</span><a class="archive-post-title" href= "/2019/08/08/SpringBoot学习-01/" >SpringBoot-01-Web工程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/07</span><a class="archive-post-title" href= "/2019/08/07/hexo-常用操作/" >Hexo常用操作</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/07</span><a class="archive-post-title" href= "/2019/08/07/Hibernate-01/" >Hibernate-01</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="Java基础"><span class="iconfont-archer">&#xe606;</span>Java基础</span>
    
        <span class="sidebar-tag-name" data-tags="Hibernate"><span class="iconfont-archer">&#xe606;</span>Hibernate</span>
    
        <span class="sidebar-tag-name" data-tags="JPA"><span class="iconfont-archer">&#xe606;</span>JPA</span>
    
        <span class="sidebar-tag-name" data-tags="sql"><span class="iconfont-archer">&#xe606;</span>sql</span>
    
        <span class="sidebar-tag-name" data-tags="Hexo"><span class="iconfont-archer">&#xe606;</span>Hexo</span>
    
        <span class="sidebar-tag-name" data-tags="swagger"><span class="iconfont-archer">&#xe606;</span>swagger</span>
    
        <span class="sidebar-tag-name" data-tags="杂货铺"><span class="iconfont-archer">&#xe606;</span>杂货铺</span>
    
        <span class="sidebar-tag-name" data-tags="SpringBoot-WEB"><span class="iconfont-archer">&#xe606;</span>SpringBoot-WEB</span>
    
        <span class="sidebar-tag-name" data-tags="SpringCloud"><span class="iconfont-archer">&#xe606;</span>SpringCloud</span>
    
        <span class="sidebar-tag-name" data-tags="分布式事务"><span class="iconfont-archer">&#xe606;</span>分布式事务</span>
    
        <span class="sidebar-tag-name" data-tags="Maven"><span class="iconfont-archer">&#xe606;</span>Maven</span>
    
        <span class="sidebar-tag-name" data-tags="ShardingJdbc"><span class="iconfont-archer">&#xe606;</span>ShardingJdbc</span>
    
        <span class="sidebar-tag-name" data-tags="Redis"><span class="iconfont-archer">&#xe606;</span>Redis</span>
    
        <span class="sidebar-tag-name" data-tags="Quartz"><span class="iconfont-archer">&#xe606;</span>Quartz</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "wtq"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


